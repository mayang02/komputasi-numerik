{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang Di Web Mayang Sapitri \u00b6 Biodata Mahasiswa \u00b6 Nama : Mayang Sapitri NIM : 180411100107 Kelas : Komputasi Numerik 4B Dosen Pengampuh : Mulaab, S.Si, M.Kom Program Studi : Teknik Informatika","title":"Profil Mahasiswa"},{"location":"#selamat-datang-di-web-mayang-sapitri","text":"","title":"Selamat Datang Di Web Mayang Sapitri"},{"location":"#biodata-mahasiswa","text":"Nama : Mayang Sapitri NIM : 180411100107 Kelas : Komputasi Numerik 4B Dosen Pengampuh : Mulaab, S.Si, M.Kom Program Studi : Teknik Informatika","title":"Biodata Mahasiswa"},{"location":"Gauss/","text":"METODE ELIMINASI GAUSS \u00b6 Eliminasi Gauss ialah sebuah cara mengoperasikan nilai-nilai yang berada di dalam matriks sehingga dapat menjadi matriks yang lebih sederhana. Caranya ialah melakukan operasi baris sehingga matriks tersebut menjadi matriks yang eselon-baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks Eselon-baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode ini berangkat dari kenyataan bahwa bila matriks A berbentuk segitiga atas (menggunakan Operasi Baris Elementer) seperti system persamaan berikut ini: Maka solusinya dapat dihitung dengan teknik penyulingan mundur ( backward substitution ): kondisi sangat penting. Sebab bila persamaan diatas menjerjakan pembagian dengan nol. Apabila kondisi tersebut tidak dipenuhi, maka SPL tidak mempunyai jawaban ELIMINASI GAUSS JORDAN \u00b6 \u200b Dalam aljabar linear, eliminasi Gauss-Jordan adalah versi dari eliminasi Gauss. Pada metode eliminasi Gauss-Jordan kita membuat nol elemen-elemen di bawah maupun di atas diagonal utama suatu matriks. Hasilnya adalah matriks tereduksi yang berupa matriks diagonal satuan (semua elemen pada diagonal utama bernilai 1, elemen-elemen lainnya nol). Dalam bentuk matriks, eliminasi Gauss-Jordan ditulis sebagai berikut : listing program : import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Masukkan ukuran Matrix : 3 Masukkan Nilai : 2 Masukkan Nilai : - 2 Masukkan Nilai : 5 Masukkan Nilai : 1 Masukkan Nilai : 5 Masukkan Nilai : 2 Masukkan Nilai : 4 Masukkan Nilai : 5 Masukkan Nilai : 2 Masukkan Hasil : 12 Masukkan Hasil : 3 Masukkan Hasil : - 4 Matrix A : [[ 2. - 2. 5. ] [ 0. 6. - 0.5 ] [ 0. 0. - 7.25 ]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = - 0.2298850574712644 Nilai X 1 = - 2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 ELIMINASI GAUSS JACOBI \u00b6 Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakukan perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X0, kemudian membentuk suatu serangkaian vector X1, X2, \u2026 yang konvergen ke X. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : - 1 Masukkan Nilai : 4 Masukkan Nilai : 7 Masukkan Nilai : - 3 Masukkan Nilai : 2 Masukkan Nilai : - 2 Masukkan Nilai : 5 Masukkan Hasil : 5 Masukkan Hasil : 20 Masukkan Hasil : 10 A : array ([[ 3. , 1. , - 1. ], [ 4. , 7. , - 3. ], [ 2. , - 2. , 5. ]]) b : array ([ 5. , 20. , 10. ]) x : array ([ 1.50602413 , 3.13253016 , 2.6506024 ]) ELIMINASI GAUSS SEINDEL \u00b6 Metode iterasi Gauss-Seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai-nilai yang berubah-ubah dan akhirnya relatif konstan. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Gauss ini mempunyai kelebihan dan kekurangan. kelebihannya yaitu Metode eliminasi gauss-seidel digunakan untuk menyelesaikan SPL yang berukuran kecil karena metode ini lebih efisien. Dengan metode iterasi Gauss-Seidel toleransi pembulatan dapat diperkecil karena iterasi dapat diteruskan sampai seteliti mungkin sesuai dengan batas toleransi yang diinginkan. kekurangannya yaitu Kelemahan dari metode ini adalah masalah pivot (titik tengah) yang harus benar\u2013benar diperhatikan, karena penyusunan yang salah akan menyebabkan iterasi menjadi divergen dan tidak diperoleh hasil yang benar def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , 3.0 ] [ 1.875 , 3.9375 , 2.9625 ] [ 1.99375 , 3.9921875 , 2.9990625 ] [ 1.99828125 , 3.9990234375 , 2.9995078125 ] [ 1.99987890625 , 3.9998779296875 , 2.9999759765625003 ] [ 1.99997548828125 , 3.9999847412109375 , 2.999993247070312 ] [ 1.9999978735351562 , 3.9999980926513667 , 2.999999530883789 ] [ 1.9999996404418945 , 3.9999997615814205 , 2.9999999038604734 ] [ 1.9999999644302369 , 3.9999999701976776 , 2.9999999917325595 ] [ 1.9999999946162794 , 3.9999999962747097 , 2.99999999859157 ] [ 1.9999999994207849 , 3.9999999995343387 , 2.9999999998614464 ] [ 1.9999999999182232 , 3.999999999941793 , 2.999999999978931 ] [ 1.9999999999907154 , 3.999999999992724 , 2.9999999999977414 ] [ 1.9999999999987457 , 3.9999999999990905 , 2.9999999999996803 ] [ 1.9999999999998526 , 3.9999999999998863 , 2.9999999999999636 ] [ 1.9999999999999807 , 3.999999999999986 , 2.999999999999995 ] [ 1.9999999999999978 , 3.9999999999999987 , 2.9999999999999996 ] [ 1.9999999999999996 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ]","title":"Gauss"},{"location":"Gauss/#metode-eliminasi-gauss","text":"Eliminasi Gauss ialah sebuah cara mengoperasikan nilai-nilai yang berada di dalam matriks sehingga dapat menjadi matriks yang lebih sederhana. Caranya ialah melakukan operasi baris sehingga matriks tersebut menjadi matriks yang eselon-baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks Eselon-baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode ini berangkat dari kenyataan bahwa bila matriks A berbentuk segitiga atas (menggunakan Operasi Baris Elementer) seperti system persamaan berikut ini: Maka solusinya dapat dihitung dengan teknik penyulingan mundur ( backward substitution ): kondisi sangat penting. Sebab bila persamaan diatas menjerjakan pembagian dengan nol. Apabila kondisi tersebut tidak dipenuhi, maka SPL tidak mempunyai jawaban","title":"METODE ELIMINASI GAUSS"},{"location":"Gauss/#eliminasi-gauss-jordan","text":"\u200b Dalam aljabar linear, eliminasi Gauss-Jordan adalah versi dari eliminasi Gauss. Pada metode eliminasi Gauss-Jordan kita membuat nol elemen-elemen di bawah maupun di atas diagonal utama suatu matriks. Hasilnya adalah matriks tereduksi yang berupa matriks diagonal satuan (semua elemen pada diagonal utama bernilai 1, elemen-elemen lainnya nol). Dalam bentuk matriks, eliminasi Gauss-Jordan ditulis sebagai berikut : listing program : import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) Masukkan ukuran Matrix : 3 Masukkan Nilai : 2 Masukkan Nilai : - 2 Masukkan Nilai : 5 Masukkan Nilai : 1 Masukkan Nilai : 5 Masukkan Nilai : 2 Masukkan Nilai : 4 Masukkan Nilai : 5 Masukkan Nilai : 2 Masukkan Hasil : 12 Masukkan Hasil : 3 Masukkan Hasil : - 4 Matrix A : [[ 2. - 2. 5. ] [ 0. 6. - 0.5 ] [ 0. 0. - 7.25 ]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = - 0.2298850574712644 Nilai X 1 = - 2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"ELIMINASI GAUSS JORDAN"},{"location":"Gauss/#eliminasi-gauss-jacobi","text":"Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakukan perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X0, kemudian membentuk suatu serangkaian vector X1, X2, \u2026 yang konvergen ke X. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Masukkan ukuran Matrix : 3 Masukkan Nilai : 3 Masukkan Nilai : 1 Masukkan Nilai : - 1 Masukkan Nilai : 4 Masukkan Nilai : 7 Masukkan Nilai : - 3 Masukkan Nilai : 2 Masukkan Nilai : - 2 Masukkan Nilai : 5 Masukkan Hasil : 5 Masukkan Hasil : 20 Masukkan Hasil : 10 A : array ([[ 3. , 1. , - 1. ], [ 4. , 7. , - 3. ], [ 2. , - 2. , 5. ]]) b : array ([ 5. , 20. , 10. ]) x : array ([ 1.50602413 , 3.13253016 , 2.6506024 ])","title":"ELIMINASI GAUSS JACOBI"},{"location":"Gauss/#eliminasi-gauss-seindel","text":"Metode iterasi Gauss-Seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai-nilai yang berubah-ubah dan akhirnya relatif konstan. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Gauss ini mempunyai kelebihan dan kekurangan. kelebihannya yaitu Metode eliminasi gauss-seidel digunakan untuk menyelesaikan SPL yang berukuran kecil karena metode ini lebih efisien. Dengan metode iterasi Gauss-Seidel toleransi pembulatan dapat diperkecil karena iterasi dapat diteruskan sampai seteliti mungkin sesuai dengan batas toleransi yang diinginkan. kekurangannya yaitu Kelemahan dari metode ini adalah masalah pivot (titik tengah) yang harus benar\u2013benar diperhatikan, karena penyusunan yang salah akan menyebabkan iterasi menjadi divergen dan tidak diperoleh hasil yang benar def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , 3.0 ] [ 1.875 , 3.9375 , 2.9625 ] [ 1.99375 , 3.9921875 , 2.9990625 ] [ 1.99828125 , 3.9990234375 , 2.9995078125 ] [ 1.99987890625 , 3.9998779296875 , 2.9999759765625003 ] [ 1.99997548828125 , 3.9999847412109375 , 2.999993247070312 ] [ 1.9999978735351562 , 3.9999980926513667 , 2.999999530883789 ] [ 1.9999996404418945 , 3.9999997615814205 , 2.9999999038604734 ] [ 1.9999999644302369 , 3.9999999701976776 , 2.9999999917325595 ] [ 1.9999999946162794 , 3.9999999962747097 , 2.99999999859157 ] [ 1.9999999994207849 , 3.9999999995343387 , 2.9999999998614464 ] [ 1.9999999999182232 , 3.999999999941793 , 2.999999999978931 ] [ 1.9999999999907154 , 3.999999999992724 , 2.9999999999977414 ] [ 1.9999999999987457 , 3.9999999999990905 , 2.9999999999996803 ] [ 1.9999999999998526 , 3.9999999999998863 , 2.9999999999999636 ] [ 1.9999999999999807 , 3.999999999999986 , 2.999999999999995 ] [ 1.9999999999999978 , 3.9999999999999987 , 2.9999999999999996 ] [ 1.9999999999999996 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ]","title":"ELIMINASI GAUSS SEINDEL"},{"location":"rbg/","text":"Metode Romberg \u00b6 Metode Romberg didasarkan pada perluasan ekstrapolasi Richardson untuk memperoleh nilai integrasi yang semakin baik. Pada setiap penerapan ekstrapolasi Richardson akan menaikkan orde galat pada hasil solusinya sebesar dua, misalkan O(h^{2N}) O(h^{2N}) --> O(h^{2N+2}) O(h^{2N+2}) Contohnya, bila I(h) dan I(2h) dihitung dengan metode Trapesium yang berorde galat *O*(*h^{2}*) *O*(*h^{2}*) , maka ekstrapolasi Richardson menghasilkan metode Simpson \u2153 yang berorde galat O(h^{4}) O(h^{4}) . Selanjutnya, bila I(h) dan I(2h) dihitung dengan metode Simpson \u2153, ekstrapolasi Richardson akan menghasilkan kaidah Boole yang berorde galat O(h^{6}) O(h^{6}) . Persamaan ekstrapolasi Richardson : \u200b Misalkan I adalah nilai integrasi sejati yang dinyatakan sebagai I= A_k+ Ch^{2} + Dh^{4}+ Eh^{6}+ ... I= A_k+ Ch^{2} + Dh^{4}+ Eh^{6}+ ... yang dalam hal ini h= \\frac{(b-a)}{n} h= \\frac{(b-a)}{n} dan A_k A_k merupakan nilai integrasi dengan metode Trapesium dengan jumlah pias n= 2^{k} n= 2^{k} dan Orde galatnya adalah O(h^{2}) O(h^{2}) . A_0, A_1,...A_k A_0, A_1,...A_k digunakan dalam persamaan ekstrapolasi Richardson untuk mendapatkan B_1, B_2, ...,B_k B_1, B_2, ...,B_k , yaitu Jadi, nilai I (yang lebih baik) sekarang adalah I = B_k + D'h^{4} + E'h^{6} +\u2026 I = B_k + D'h^{4} + E'h^{6} +\u2026 dengan orde galat B_k B_k adalah O(h^{4}) O(h^{4}) . Selanjutnya, gunakan B_1, B_2 ,.., B_k B_1, B_2 ,.., B_k pada persamaan ekstrapolasi Richardson untuk mendapatkan runtunan C_2, C_3,..., C_k C_2, C_3,..., C_k , yaitu Jadi, nilai I (yang lebih baik) sekarang adalah I = C_k + E \" h^{6} + ... I = C_k + E \" h^{6} + ... dengan orde galat C_k C_k adalah O(h^{6}) O(h^{6}) . Demikian seterusnya. Dari runtunan tersebut, diperoleh tabel yang dinamakan tabel Romberg seperti berikut ini Implementasi Pemrograman \u00b6 Contoh 1 : Dalam contoh ini kita dapat melihat bahwa dengan menggunakan metode scipy.integrate.romberg() , kita bisa mendapatkan integrasi romberg dari fungsi yang dapat dipanggil dari batas a ke b dengan menggunakan metode scipy.integrate.romberg() . # import numpy and scipy.integrate import numpy as np from integrate import scipy gfg = lambda x : np . exp ( - x * * 2 ) # using scipy.integrate.romberg() geek = integrate . romberg ( gfg , 0 , 3 , show = True ) print ( geek ) Output Romberg integrasi <function vectorize1..vfunc di 0x00000209C3641EA0> dari [0, 3] Langkah StepSize Hasil 1 3.000000 1.500185 2 1.500000 0,908191 0,710860 4 0.750000 0.886180 0.878843 0.890042 8 0.375000 0.886199 0.886206 0.886696 0.886643 16 0.187500 0.886205 0.886207 0.886207 0.886200 0.886198 32 0,093750 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 64 0.046875 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 128 0.023438 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 Hasil akhir adalah 0,8862073482595311 setelah 129 evaluasi fungsi. Contoh 2 # import numpy and scipy.integrate import numpy as np from integrate import scipy gfg = lambda x : np . exp ( - x * * 2 ) + 1 / np . sqrt ( np . pi ) # using scipy.integrate.romberg() geek = integrate . romberg ( gfg , 1 , 2 , show = True ) print ( geek ) Ooutput Integrasi Romberg dari <function vectorize1..vfunc at 0x00000209E1605400> dari [1, 2] Langkah StepSize Hasil 1 1,000000 0,757287 2 0,500000 0,713438 0,698822 4 0.250000 0.702909 0.699400 0.699438 8 0.125000 0.700310 0.699444 0.699447 0.699447 16 0,062500 0,699663 0,699447 0,699447 0,699447 0,699447 32 0.031250 0.699501 0.699447 0.699447 0.699447 0.699447 0.699447 Hasil akhir adalah 0,6994468414978009 setelah 33 evaluasi fungsi.","title":"Metode Romberg"},{"location":"rbg/#metode-romberg","text":"Metode Romberg didasarkan pada perluasan ekstrapolasi Richardson untuk memperoleh nilai integrasi yang semakin baik. Pada setiap penerapan ekstrapolasi Richardson akan menaikkan orde galat pada hasil solusinya sebesar dua, misalkan O(h^{2N}) O(h^{2N}) --> O(h^{2N+2}) O(h^{2N+2}) Contohnya, bila I(h) dan I(2h) dihitung dengan metode Trapesium yang berorde galat *O*(*h^{2}*) *O*(*h^{2}*) , maka ekstrapolasi Richardson menghasilkan metode Simpson \u2153 yang berorde galat O(h^{4}) O(h^{4}) . Selanjutnya, bila I(h) dan I(2h) dihitung dengan metode Simpson \u2153, ekstrapolasi Richardson akan menghasilkan kaidah Boole yang berorde galat O(h^{6}) O(h^{6}) . Persamaan ekstrapolasi Richardson : \u200b Misalkan I adalah nilai integrasi sejati yang dinyatakan sebagai I= A_k+ Ch^{2} + Dh^{4}+ Eh^{6}+ ... I= A_k+ Ch^{2} + Dh^{4}+ Eh^{6}+ ... yang dalam hal ini h= \\frac{(b-a)}{n} h= \\frac{(b-a)}{n} dan A_k A_k merupakan nilai integrasi dengan metode Trapesium dengan jumlah pias n= 2^{k} n= 2^{k} dan Orde galatnya adalah O(h^{2}) O(h^{2}) . A_0, A_1,...A_k A_0, A_1,...A_k digunakan dalam persamaan ekstrapolasi Richardson untuk mendapatkan B_1, B_2, ...,B_k B_1, B_2, ...,B_k , yaitu Jadi, nilai I (yang lebih baik) sekarang adalah I = B_k + D'h^{4} + E'h^{6} +\u2026 I = B_k + D'h^{4} + E'h^{6} +\u2026 dengan orde galat B_k B_k adalah O(h^{4}) O(h^{4}) . Selanjutnya, gunakan B_1, B_2 ,.., B_k B_1, B_2 ,.., B_k pada persamaan ekstrapolasi Richardson untuk mendapatkan runtunan C_2, C_3,..., C_k C_2, C_3,..., C_k , yaitu Jadi, nilai I (yang lebih baik) sekarang adalah I = C_k + E \" h^{6} + ... I = C_k + E \" h^{6} + ... dengan orde galat C_k C_k adalah O(h^{6}) O(h^{6}) . Demikian seterusnya. Dari runtunan tersebut, diperoleh tabel yang dinamakan tabel Romberg seperti berikut ini","title":"Metode Romberg"},{"location":"rbg/#implementasi-pemrograman","text":"Contoh 1 : Dalam contoh ini kita dapat melihat bahwa dengan menggunakan metode scipy.integrate.romberg() , kita bisa mendapatkan integrasi romberg dari fungsi yang dapat dipanggil dari batas a ke b dengan menggunakan metode scipy.integrate.romberg() . # import numpy and scipy.integrate import numpy as np from integrate import scipy gfg = lambda x : np . exp ( - x * * 2 ) # using scipy.integrate.romberg() geek = integrate . romberg ( gfg , 0 , 3 , show = True ) print ( geek ) Output Romberg integrasi <function vectorize1..vfunc di 0x00000209C3641EA0> dari [0, 3] Langkah StepSize Hasil 1 3.000000 1.500185 2 1.500000 0,908191 0,710860 4 0.750000 0.886180 0.878843 0.890042 8 0.375000 0.886199 0.886206 0.886696 0.886643 16 0.187500 0.886205 0.886207 0.886207 0.886200 0.886198 32 0,093750 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 64 0.046875 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 128 0.023438 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 Hasil akhir adalah 0,8862073482595311 setelah 129 evaluasi fungsi. Contoh 2 # import numpy and scipy.integrate import numpy as np from integrate import scipy gfg = lambda x : np . exp ( - x * * 2 ) + 1 / np . sqrt ( np . pi ) # using scipy.integrate.romberg() geek = integrate . romberg ( gfg , 1 , 2 , show = True ) print ( geek ) Ooutput Integrasi Romberg dari <function vectorize1..vfunc at 0x00000209E1605400> dari [1, 2] Langkah StepSize Hasil 1 1,000000 0,757287 2 0,500000 0,713438 0,698822 4 0.250000 0.702909 0.699400 0.699438 8 0.125000 0.700310 0.699444 0.699447 0.699447 16 0,062500 0,699663 0,699447 0,699447 0,699447 0,699447 32 0.031250 0.699501 0.699447 0.699447 0.699447 0.699447 0.699447 Hasil akhir adalah 0,6994468414978009 setelah 33 evaluasi fungsi.","title":"Implementasi Pemrograman"},{"location":"tugas1/","text":"Pendekatan Deret MacLaurin \u00b6 Deret MacLaurin \u00b6 DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan f'(x), f''(x), f'''(x) dan seterusnya yang kontinyu dalam interval I dengan a, x I maka untuk x disekitar a yaitu |x-a|< R , f(x) dapat diekspansi kedalam Deret Taylor. Dalam kasus khusus jika a=0 , maka disebut Deret MacLaurin atau sering disebut Deret Taylor baku. Dan didefinisikan sebagai berikut Definisi : $$ f(x)=f(0)+\\frac{f^{1}(0)}{1 !} x+\\frac{f^{2}(0)}{2 !} x^{2}+\\frac{f^{3}(0)}{3 !} x^{3}+\\frac{f^{4}(0)}{4 !} x^{4} + ...+\\frac{f^{n}(0)}{n!}x^{n!} $$ Atau bisa dinyatakan dengan: $$ f(x)=\\sum_{n=0}^\\infty \\frac{f^{(n)}n(0)}{n!}x^{n} $$ Deret MacLaurin sangat bermanfaat dalam metode numerik untuk menghitung atau menghampiri nilai-nilai fungsi yang sudah dihitung secara manual seperti nilai sin x, cos x , eksponensial, dll. Tentu kita tidak akan bisa menghitung nilai-nilai fungsi tersebut tanpa menggunakan bantuan kalkulator atau tabel. Dalam tulisan ini saya akan mencoba untuk mendekati fungsi-fungsi tersebut menggunakan Deret MacLaurin. Tugas \u00b6 Hitunglah e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001. Penyelesaian \u00b6 Fungsi awal exponen : $$ f(x) = e^{3x}\\ $$ Dapat juga didefinisikan dengan rumus : $$ e^{3x} = \\sum_{n=0}^\\infty \\frac{(3x)^n}{n!} = \\sum_{n=0}^\\infty (3)^n\\frac{x^n}{n!} $$ Deret turunan : $$ f(a)=e^{3x} $$ $$ f^{1}(a)=3e^{3x} $$ f^{2}(a)=9e^{3x} f^{2}(a)=9e^{3x} f^{3}(a)=27e^{3x} f^{3}(a)=27e^{3x} f^{4}(a)=81e^{2x} f^{4}(a)=81e^{2x} ... ... Berikut adalah penyelesaian untuk mencari nilai expansi : $$ f(x)=f(0)+\\frac{f^{1}(0)}{1 !} x+\\frac{f^{2}(0)}{2 !} x^{2}+\\frac{f^{3}(0)}{3 !} x^{3}+\\frac{f^{4}(0)}{4 !} x^{4} + ...+\\frac{f^{n}(0)}{n!}x^{n!} $$ nilai turunan pada tabel dimasukkan kedalam rumus sehingga didapatkan seperti ini : $$ f(x)=1+\\frac{3}{1 !} x+\\frac{9}{2 !} x^{2}+\\frac{27}{3 !} x^{3}+\\frac{81}{4 !} x^{4} + ...+\\frac{3^{n}}{n!} x^{n} $$ kemudian, nilai x diganti dengan 4 : $$ f(x)=1+\\frac{3}{1 !} 4+\\frac{9}{2 !} 4^{2}+\\frac{27}{3 !} 4^{3}+\\frac{81}{4 !} 4^{4} + ...+\\frac{3^{n}}{n!} 4^{n} $$ perhitungan diatas akan terus berulang hingga nilai selisih mendekati nilai error yang ditentukan yaitu kurang dari 0,001 Listing Program \u00b6 Script import math error = 0.001 def f ( x ): f_turunan = 1 current = i = 0 iteration = True while iteration : old = current current += ( f_turunan * ( x ** i )) / math . factorial ( i ) print ( 'f ke-' , i , '=' , current , 'Ea=' , current - old ) if current - old < error : iteration = False else : f_turunan *= 3 i += 1 f ( 4 ) Output f ke - 0 = 1.0 Ea = 1.0 f ke - 1 = 13.0 Ea = 12.0 f ke - 2 = 85.0 Ea = 72.0 f ke - 3 = 373.0 Ea = 288.0 f ke - 4 = 1237.0 Ea = 864.0 f ke - 5 = 3310.6 Ea = 2073.6 f ke - 6 = 7457.799999999999 Ea = 4147.199999999999 f ke - 7 = 14567.285714285714 Ea = 7109.4857142857145 f ke - 8 = 25231.514285714286 Ea = 10664.228571428572 f ke - 9 = 39450.485714285714 Ea = 14218.971428571429 f ke - 10 = 56513.25142857143 Ea = 17062.765714285713 f ke - 11 = 75127.17766233766 Ea = 18613.926233766237 f ke - 12 = 93741.1038961039 Ea = 18613.926233766237 f ke - 13 = 110923.18965034965 Ea = 17182.085754245752 f ke - 14 = 125650.69172541745 Ea = 14727.502075067794 f ke - 15 = 137432.69338547168 Ea = 11782.00166005423 f ke - 16 = 146269.19463051236 Ea = 8836.50124504068 f ke - 17 = 152506.7249211293 Ea = 6237.530290616938 f ke - 18 = 156665.07844820726 Ea = 4158.3535270779685 f ke - 19 = 159291.4069916249 Ea = 2626.3285434176505 f ke - 20 = 160867.20411767552 Ea = 1575.797126050602 f ke - 21 = 161767.65961827585 Ea = 900.4555006003357 f ke - 22 = 162258.81716405787 Ea = 491.1575457820145 f ke - 23 = 162515.07327490064 Ea = 256.25611084277625 f ke - 24 = 162643.20133032204 Ea = 128.12805542140268 f ke - 25 = 162704.7027969243 Ea = 61.501466602261644 f ke - 26 = 162733.08808920227 Ea = 28.385292277962435 f ke - 27 = 162745.70377465914 Ea = 12.61568545686896 f ke - 28 = 162751.1104969978 Ea = 5.406722338666441 f ke - 29 = 162753.3477614138 Ea = 2.237264416005928 f ke - 30 = 162754.2426671802 Ea = 0.8949057663849089 f ke - 31 = 162754.58908231556 Ea = 0.34641513536917046 f ke - 32 = 162754.71898799133 Ea = 0.12990567577071488 f ke - 33 = 162754.7662264189 Ea = 0.04723842756357044 f ke - 34 = 162754.7828988051 Ea = 0.016672386205755174 f ke - 35 = 162754.7886150518 Ea = 0.005716246698284522 f ke - 36 = 162754.79052046736 Ea = 0.0019054155563935637 f ke - 37 = 162754.79113843996 Ea = 0.0006179726042319089 Jadi, proses perulangan akan berhenti pada iterasi ke-37 karena selisih dari expansi yang dihasilkan mendekati nilai error yang ditentukan yaitu e < 0,001. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"MacLaurin"},{"location":"tugas1/#pendekatan-deret-maclaurin","text":"","title":"Pendekatan Deret MacLaurin"},{"location":"tugas1/#deret-maclaurin","text":"DERET MacLaurin adalah Suatu fungsi f(x) yang memiliki turunan f'(x), f''(x), f'''(x) dan seterusnya yang kontinyu dalam interval I dengan a, x I maka untuk x disekitar a yaitu |x-a|< R , f(x) dapat diekspansi kedalam Deret Taylor. Dalam kasus khusus jika a=0 , maka disebut Deret MacLaurin atau sering disebut Deret Taylor baku. Dan didefinisikan sebagai berikut Definisi : $$ f(x)=f(0)+\\frac{f^{1}(0)}{1 !} x+\\frac{f^{2}(0)}{2 !} x^{2}+\\frac{f^{3}(0)}{3 !} x^{3}+\\frac{f^{4}(0)}{4 !} x^{4} + ...+\\frac{f^{n}(0)}{n!}x^{n!} $$ Atau bisa dinyatakan dengan: $$ f(x)=\\sum_{n=0}^\\infty \\frac{f^{(n)}n(0)}{n!}x^{n} $$ Deret MacLaurin sangat bermanfaat dalam metode numerik untuk menghitung atau menghampiri nilai-nilai fungsi yang sudah dihitung secara manual seperti nilai sin x, cos x , eksponensial, dll. Tentu kita tidak akan bisa menghitung nilai-nilai fungsi tersebut tanpa menggunakan bantuan kalkulator atau tabel. Dalam tulisan ini saya akan mencoba untuk mendekati fungsi-fungsi tersebut menggunakan Deret MacLaurin.","title":"Deret MacLaurin"},{"location":"tugas1/#tugas","text":"Hitunglah e^3x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001.","title":"Tugas"},{"location":"tugas1/#penyelesaian","text":"Fungsi awal exponen : $$ f(x) = e^{3x}\\ $$ Dapat juga didefinisikan dengan rumus : $$ e^{3x} = \\sum_{n=0}^\\infty \\frac{(3x)^n}{n!} = \\sum_{n=0}^\\infty (3)^n\\frac{x^n}{n!} $$ Deret turunan : $$ f(a)=e^{3x} $$ $$ f^{1}(a)=3e^{3x} $$ f^{2}(a)=9e^{3x} f^{2}(a)=9e^{3x} f^{3}(a)=27e^{3x} f^{3}(a)=27e^{3x} f^{4}(a)=81e^{2x} f^{4}(a)=81e^{2x} ... ... Berikut adalah penyelesaian untuk mencari nilai expansi : $$ f(x)=f(0)+\\frac{f^{1}(0)}{1 !} x+\\frac{f^{2}(0)}{2 !} x^{2}+\\frac{f^{3}(0)}{3 !} x^{3}+\\frac{f^{4}(0)}{4 !} x^{4} + ...+\\frac{f^{n}(0)}{n!}x^{n!} $$ nilai turunan pada tabel dimasukkan kedalam rumus sehingga didapatkan seperti ini : $$ f(x)=1+\\frac{3}{1 !} x+\\frac{9}{2 !} x^{2}+\\frac{27}{3 !} x^{3}+\\frac{81}{4 !} x^{4} + ...+\\frac{3^{n}}{n!} x^{n} $$ kemudian, nilai x diganti dengan 4 : $$ f(x)=1+\\frac{3}{1 !} 4+\\frac{9}{2 !} 4^{2}+\\frac{27}{3 !} 4^{3}+\\frac{81}{4 !} 4^{4} + ...+\\frac{3^{n}}{n!} 4^{n} $$ perhitungan diatas akan terus berulang hingga nilai selisih mendekati nilai error yang ditentukan yaitu kurang dari 0,001","title":"Penyelesaian"},{"location":"tugas1/#listing-program","text":"Script import math error = 0.001 def f ( x ): f_turunan = 1 current = i = 0 iteration = True while iteration : old = current current += ( f_turunan * ( x ** i )) / math . factorial ( i ) print ( 'f ke-' , i , '=' , current , 'Ea=' , current - old ) if current - old < error : iteration = False else : f_turunan *= 3 i += 1 f ( 4 ) Output f ke - 0 = 1.0 Ea = 1.0 f ke - 1 = 13.0 Ea = 12.0 f ke - 2 = 85.0 Ea = 72.0 f ke - 3 = 373.0 Ea = 288.0 f ke - 4 = 1237.0 Ea = 864.0 f ke - 5 = 3310.6 Ea = 2073.6 f ke - 6 = 7457.799999999999 Ea = 4147.199999999999 f ke - 7 = 14567.285714285714 Ea = 7109.4857142857145 f ke - 8 = 25231.514285714286 Ea = 10664.228571428572 f ke - 9 = 39450.485714285714 Ea = 14218.971428571429 f ke - 10 = 56513.25142857143 Ea = 17062.765714285713 f ke - 11 = 75127.17766233766 Ea = 18613.926233766237 f ke - 12 = 93741.1038961039 Ea = 18613.926233766237 f ke - 13 = 110923.18965034965 Ea = 17182.085754245752 f ke - 14 = 125650.69172541745 Ea = 14727.502075067794 f ke - 15 = 137432.69338547168 Ea = 11782.00166005423 f ke - 16 = 146269.19463051236 Ea = 8836.50124504068 f ke - 17 = 152506.7249211293 Ea = 6237.530290616938 f ke - 18 = 156665.07844820726 Ea = 4158.3535270779685 f ke - 19 = 159291.4069916249 Ea = 2626.3285434176505 f ke - 20 = 160867.20411767552 Ea = 1575.797126050602 f ke - 21 = 161767.65961827585 Ea = 900.4555006003357 f ke - 22 = 162258.81716405787 Ea = 491.1575457820145 f ke - 23 = 162515.07327490064 Ea = 256.25611084277625 f ke - 24 = 162643.20133032204 Ea = 128.12805542140268 f ke - 25 = 162704.7027969243 Ea = 61.501466602261644 f ke - 26 = 162733.08808920227 Ea = 28.385292277962435 f ke - 27 = 162745.70377465914 Ea = 12.61568545686896 f ke - 28 = 162751.1104969978 Ea = 5.406722338666441 f ke - 29 = 162753.3477614138 Ea = 2.237264416005928 f ke - 30 = 162754.2426671802 Ea = 0.8949057663849089 f ke - 31 = 162754.58908231556 Ea = 0.34641513536917046 f ke - 32 = 162754.71898799133 Ea = 0.12990567577071488 f ke - 33 = 162754.7662264189 Ea = 0.04723842756357044 f ke - 34 = 162754.7828988051 Ea = 0.016672386205755174 f ke - 35 = 162754.7886150518 Ea = 0.005716246698284522 f ke - 36 = 162754.79052046736 Ea = 0.0019054155563935637 f ke - 37 = 162754.79113843996 Ea = 0.0006179726042319089 Jadi, proses perulangan akan berhenti pada iterasi ke-37 karena selisih dari expansi yang dihasilkan mendekati nilai error yang ditentukan yaitu e < 0,001. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$'],['$','$']]} });","title":"Listing Program"},{"location":"tugas2/","text":"Newton Raphson \u00b6 Metode Newton Raphson \u00b6 Metode Newton Raphson biasa digunakan dalam mencari akar dari suatu persamaan non linier, jika diasumsikan f f mempunyai turunan kontinu f' f' . Metode Newton Raphson merupakan salah satu metode terpopuler untuk menghampiri penyelesaian f(x)=0 f(x)=0 secara iteratif. Metode ini dianggap lebih mudah dari Metode Bagi Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis \\imath \\imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis \\imath \\imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis \\imath : y - y_0 = m(x - x_0) \\imath : y - y_0 = m(x - x_0) $$ y - f(x_0) = f'(x_0)(x - x_0) $$ x_1 x_1 perpotongan garis \\imath \\imath dengan sumbu - x $$ 0 - f(x_0) = f'(x_0)(x - x_0) $$ y = 0 dan x = x_1 x_1 maka koordinat titik ( x_1 x_1 ,0) $$ - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) $$ sehingga di dapat sebuah rumus : $$ x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} $$ Algoritma dan Pemrograman Newton Rhapson \u00b6 Dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4 Implementasi Pemrograman \u00b6 import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 5 * x ) + 6 ) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 5 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 4 Iterasi ke = 1 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f ( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f ( 0.3574028224700733 ) = - 6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x -5x+6 f(x) = e^x -5x+6 maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x -5 f'(x) = e^x -5 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Newton Raphson"},{"location":"tugas2/#newton-raphson","text":"","title":"Newton Raphson"},{"location":"tugas2/#metode-newton-raphson","text":"Metode Newton Raphson biasa digunakan dalam mencari akar dari suatu persamaan non linier, jika diasumsikan f f mempunyai turunan kontinu f' f' . Metode Newton Raphson merupakan salah satu metode terpopuler untuk menghampiri penyelesaian f(x)=0 f(x)=0 secara iteratif. Metode ini dianggap lebih mudah dari Metode Bagi Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan x_0 x_0 sebagai titik awal, kemudian menarik garis lurus (misal garis \\imath \\imath ) yang menyinggung titik f(x_0) f(x_0) . Hal ini berakibat garis \\imath \\imath memotong sumbu x x di titik x_1 x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n x_2 , x_3 , ... , x_n dengan x_n x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis \\imath : y - y_0 = m(x - x_0) \\imath : y - y_0 = m(x - x_0) $$ y - f(x_0) = f'(x_0)(x - x_0) $$ x_1 x_1 perpotongan garis \\imath \\imath dengan sumbu - x $$ 0 - f(x_0) = f'(x_0)(x - x_0) $$ y = 0 dan x = x_1 x_1 maka koordinat titik ( x_1 x_1 ,0) $$ - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) $$ sehingga di dapat sebuah rumus : $$ x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_n = x_{n-1} - \\frac{f(x_{n-1})}{f'(x_{n-1})} $$","title":"Metode Newton Raphson"},{"location":"tugas2/#algoritma-dan-pemrograman-newton-rhapson","text":"Dari rumus yang kita dapat diatas kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 f(x) = 0 sebagai berikut : Didefinisikan fungsi f f dengan f(x) f(x) dan f'(x) f'(x) Ditentukan Epsilon sebagai Toleransi kesalahan serta iterasi maksimum untuk Stopping Condition Dipilih tebakan awal x_0 x_0 Dihitung f( x_0 x_0 ) dan f'( x_0 x_0 ) Dihitung x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 x_b = x_0 - \\frac{f(x_0)}{f'(x_0)}f'(x_0) \\neq 0 . jika f'(x_0) = 0 f'(x_0) = 0 kembali ke langkah - 3 Jika \\left | x_b - x_0 \\right | < \\varepsilon \\left | x_b - x_0 \\right | < \\varepsilon . itersasi lebih dari iterasi maksimum tulis x_{hampiran} = x_b x_{hampiran} = x_b sebagai hasil hampiran akar; jika tidak, lanjutkan ke langkah berikutnya. Ganti nilai x_0 x_0 dengan x_0 = x_b x_0 = x_b dan kembali ke langkah-4","title":"Algoritma dan Pemrograman Newton Rhapson"},{"location":"tugas2/#implementasi-pemrograman","text":"import math e = 2.71828 def fungsi ( x ): x = float (( e ** x ) - ( 5 * x ) + 6 ) return x def fungsiturunan ( x ): x = float (( e ** x ) - ( 5 )) return x x = float ( input ( 'Masukkan nilai awal = ' )) error = float ( input ( 'Masukkan nilai error = ' )) perulangan = int ( input ( 'Masukkan maksimal pengulangan = ' )) iterasi = 0 selisih = error + 1 while iterasi <= perulangan and selisih > error : iterasi += 1 f_2 = x - ( fungsi ( x ) / fungsiturunan ( x )) selisih = math . fabs ( f_2 - x ) x = f_2 print ( \"Iterasi ke = \" , iterasi , \", x = \" , f_2 , \", f(\" , f_2 , \") = \" , fungsi ( f_2 ), \", selisih = \" , error ) if iterasi <= perulangan : print ( \"Perulangan Mencapai Batas Maksimal dengan hasil = \" , f_2 ) else : print ( \"Toleransi tidak terpenuhi\" ) Dengan Output sebagai berikut : Masukkan nilai awal = 0 Masukkan nilai error = 0.0001 Masukkan maksimal pengulangan = 4 Iterasi ke = 1 , x = 0.3333333333333333 , f ( 0.3333333333333333 ) = 0.06227877883196098 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3333333333333333 Iterasi ke = 2 , x = 0.35724635301940616 , f ( 0.35724635301940616 ) = 0.0004022049593612742 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35724635301940616 Iterasi ke = 3 , x = 0.35740281572145605 , f ( 0.35740281572145605 ) = 1.734656973617632e-08 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.35740281572145605 Iterasi ke = 4 , x = 0.3574028224700733 , f ( 0.3574028224700733 ) = - 6.439293542825908e-15 , selisih = 0.0001 Perulangan Mencapai Batas Maksimal dengan hasil = 0.3574028224700733 Penjelasan : Importh Library math karena kita menggunakan contoh fungsi f(x) = e^x -5x+6 f(x) = e^x -5x+6 maka kita membuat sebuah fungsi yang sesuai , dan juga fungsi turunannya yaitu f'(x) = e^x -5 f'(x) = e^x -5 Membuat sebuah inputan untuk X , Error / Epsilon , serta Maksimal perulangan untuk stopping condition lalu deklarasikan iterasi = 0 untuk perulangan yang ke 0 nantinya dan akan ditambah setiap kali perulangan deklarasikan selisih untuk x_b - x_0 x_b - x_0 untuk perbandingan lakukan perulangan dengan kondisi iterasi kurang dari sama dengan inputan maksimal iterasi dan selisih lebih dari error / epsilon hitung x_b x_b dengan rumus yang sudah kita dapatkan sebelumnya lalu lakukan perbandingan jika mencapai nilai True maka toleransi tidak terpenuhi namun perulangan sudah mencapai batas jika pengecekan selisih > error bernilai bernilai True maka toleransi akan terpenuhi dengan nilai error serta fungsi x pada iterasi ke n","title":"Implementasi Pemrograman"}]}